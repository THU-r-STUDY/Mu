# [백준 12904](https://www.acmicpc.net/problem/12904). A와 B

## ✏️ 문제 설명
* 아래 두 가지 연산 중 하나만 골라서 문자열 S를 T로 만들 수 있는지?
  * 문자열의 뒤에 A를 추가한다.
  * 문자열을 뒤집고 뒤에 B를 추가한다.

## ✏️ Solution
* 편의상 첫 번째 연산을 A연산(A함수), 두 번째 연산을 B연산(B함수)이라 하자.
* A함수와 B함수는 아래 표처럼 두 가지 변수를 가진다고 할 수 있다.
  * 문자가 추가되는 위치가 앞인지 뒤인지, 문자열이 뒤집히는 지를 고려해야하며, 
    예제 1의 경우 S는 최소 3번의 연산을 수행해야 되는데 이 때 가능한 결과가 최대 8개가 나온다(2^3)
    
* **💡 그런데 T를 S로 전환한다면 어떨까?**
  T를 S로 전환하면서 취하는 동작은 조금 변하게 된다.
    * 문자열 맨 뒤의 A를 삭제한다.
    * 문자열 맨 뒤의 B를 삭제하고, 문자열을 뒤집는다.
  이 때의 함수를 A’, B’라고 하자. A’함수와 B’함수의 변수는 아래와 같이 변한다.

  삭제되는 위치가 뒤로 통일되며, 그러면서도 둘 다 삭제가 먼저 일어난다. 
  **말인즉슨 A’연산과 B’연산의 차이는 문자열을 뒤집느냐 아니냐에서 밖에 없다는 뜻이다.**
  그러므로 T의 맨 끝에서부터 차례대로 A’연산 또는 B’연산을 수행하면 된다.

* 둘 중 어느 연산을 수행해야하는 지도 사실 답이 정해져 있다.
  현재 T 맨 끝의 문자가 A일 때 A’연산과 B’연산 중 어떤 걸 택해야할까?
  또는 현재 T 맨 끝의 문자가 B일 때 A’연산과 B’연산 중 어떤 걸 택해야할까?

* A일 때는 B’ 연산을 수행할 수 없다. 왜냐하면 제거할 B가 맨 뒤에 없기 때문이다.
  마찬가지로 B일때는 A’연산을 수행할 수 없다.
  **해야할 연산이 정해져 있다고 보면 된다.** 이에 따라 경우의 수는 앞선 S→T전환과 다르게 그냥 1이다.

 * 최종 로직은 아래와 같다.
   1. T 끝에 문자가 A이면 A’ 연산을, B이면 B’ 연산을 수행
   2. 1을 S와 T의 길이가 같아질 때까지 시행
   3. 길이가 같아진 순간, 두 값이 일치하는 지 아닌 지 판단하여 0 또는 1을 출력.

  이제 코드가 아주 간단해진다.
  


## ✏️ 복잡도 분석
```
while (S.length() != T.length()) {
    char end = T.charAt(T.length() - 1); // 문자열 T의 마지막 글자. A 또는 B
    T = T.substring(0, T.length() - 1); // 마지막 글자 제거

    if (end == 'B') {
        T = new StringBuilder(T).reverse().toString(); // 'B'라면 문자열을 뒤집음
    }
}

```


👉 T.length()가 최대 1000이므로, 루프는 최대 O(n)번 만큼 돈다.

👉 문자열의 마지막 글자를 제거하는 연산은 O(1)

👉 그러나 문자열을 뒤집는 reverse()부분의 경우 문자열 길이만큼의 시간이 소요된다. 최악의 경우, 이 연산은 T의 길이가 999일 때부터 시작하여 길이가 1까지 매번 문자열을 뒤집게 되므로 최대 O(n^2)의 시간이 소요된다.


  ### 전체 시간 복잡도: O(n^2)
